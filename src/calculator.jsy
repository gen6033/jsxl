%{
Utils = require ("./utils");
Range = require ("./range").Range;

function yyerror(msg) {
  console.log(msg);
}


module.exports = function(worksheet, formula){

  //グローバル汚染対策
  "use strict";
  var yystate;
  var yychar;
  var yysp;
  var yyerrflag;
  var yyn;
  var yyl;
  var yyval;
  var yyp;

  var ans;
  if(formula === undefined){
    return;
  }

  function getValue(range){
    if(range.size == 1){
      var cell;
      range.each(function(r, c){
        cell = worksheet.getCell(r, c);
      });
      if(cell.formula){
        return cell.calculate();
      }else{
        return cell.value;
      }
    }
    throw new Error("#!VALUE");
  }
  function expectNumber(x){
    if(x instanceof Range){
      x = Number(getValue(x));
    }
    if(!Utils.isNumber(x)){
      throw new Error("NaN");
    }
    return x;
  }
  function expectString(x){
    if(x instanceof Range){
      x = getValue(x);
    }
    if(!Utils.isString(x)){
      throw new Error("NaN");
    }
    return x;
  }
  function expectRange(x){
    if(!(x instanceof Range)){
      throw new Error("#!VALUE");
    }
    return x;
  }
  function expectList(x){
    if(!Array.isArray(x)){
      throw new Error("#!VALUE");
    }
    return x;
  }
%}


%token CELL STRING NUMBER IDENT TRUE FALSE
%token SUM

%left IGNORE
%left ','
%nonassoc '<' LE '>' GE '=' NEQ
%left '+' '-'
%left '*' '/' '&'
%left '^'
%left SPACES
%left ':'
%left SIGN

%%
start: expression {ans = $1;}
  ;

expression: spaces term spaces {$$=$2;}
  ;

term : constant
  | range
  | function_call
  | binary_operation
  | '(' expression ')' {$$=$2;}
  | '+' term %prec SIGN {$$=expectNumber($2);}
  | '-' term %prec SIGN {$$=-expectNumber($2);}
  ;
constant : FALSE
  | TRUE
  | NUMBER
  | STRING
  ;

binary_operation : term '+' term {$$ = expectNumber($1)+expectNumber($3);}
  | term '-' term {$$ = expectNumber($1)-expectNumber($3);}
  | term '*' term {$$ = expectNumber($1)*expectNumber($3);}
  | term '/' term {$$ = expectNumber($1)/expectNumber($3);}
  | term '^' term {$$ = Math.pow(expectNumber($1), expectNumber($3));}
  | term '&' term {$$ = expectString($1)+expectString($3);}
  | term '<' term {$$ = $1 < $3;}
  | term LE term {$$ = $1 <= $3;}
  | term '>' term {$$ = $1 > $3;}
  | term GE term {$$ = $1 >= $3;}
  | term '=' term {$$ = $1 === $3;}
  | term NEQ  term {$$ = $1 !== $3;}
  ;

function_call: func_sum
  ;

func_sum: SUM '(' expression ')' {
      var sum = 0;
      var list = [].concat($3);
      for(var i = 0; i < list.length; i++){
        var expr = list[i];
        if(expr instanceof Range){
          expr.each(function(r, c){
            var cell = worksheet.getCell(r, c);
            var val = cell.value;
            if(cell.formula){
              val = expectNumber(cell.calculate());
            }
            if(Utils.isNumber(val)){
              sum += Number(val);
            }
          })
        }else{
          sum += expectNumber(expr);
        }
      }
      $$ = sum;
    }
  ;
range: CELL
  | term ':' term {$$ = $1.union($3).unify();}
  | term SPACES term {$$ = $1.intersection($3);}
  | term ',' term {
      if($1 instanceof Range && $3 instanceof Range){
        $$ = $1.union($3);
      }else{
        var list = [].concat($1)
        list.push($3);
        $$ = list;
      }
    }
  ;

spaces: SPACES %prec IGNORE
  | %prec IGNORE
  ;
%%

  /* Lexical analyzer */


  function yylex()
  {
    if (buffer.length == 0)
      return 0;

    var m;

    //セル参照
    m = buffer.match(/^\$?[A-Z]+\$?\d+/);
    if(m){
      yylval = new Range(m[0]);
      buffer = buffer.substr(m[0].length);
      return CELL;
    }
    //数字
    m = buffer.match(/^\d+(?:\.\d+)?/);
    if(m){
      yylval = Number(m[0]);
      buffer = buffer.substr(m[0].length);
      return NUMBER;
    }
    //文字列
    m = buffer.match(/^"((?:""|[^"])*)"/);
    if(m){
      yylval = m[1].replace(/""/g, '"');
      buffer = buffer.substr(m[0].length);
      return STRING;
    }
    //IDENT
    m = buffer.match(/^[A-Z_]+/i);
    if(m){
      yylval = m[0].toUpperCase();
      buffer = buffer.substr(m[0].length);
      switch(yylval){
        case "TRUE":
          yylval = true;
          return TRUE;
        case "FALSE":
          yylval = false;
          return FALSE;
        case "SUM":
          return SUM;
        default:
          return IDENT;
      }
    }
    //binary operator
    m = buffer.match(/^\s*(=|<>|<=|>=|<|>|\+|-|\*|\/|\^|&|,|:)\s*/i);
    if(m){
      yylval = m[1];
      buffer = buffer.substr(m[0].length);
      switch(m[1]){
        case "<>":
          return NEQ;
        case "<=":
          return NEQ;
        case ">=":
          return NEQ;
        default:
          return yylval.charCodeAt(0);
      }
    }

    //スペースの連続
    m = buffer.match(/^\s+/);
    if(m){
      yylval = m[0];
      buffer = buffer.substr(m[0].length);
      return SPACES;
    }

    yylval = buffer.substr(0, 1);
    buffer = buffer.substr(1);
    return yylval.charCodeAt(0);
  }

  buffer = formula;
  yyparse();
  return ans;
};
